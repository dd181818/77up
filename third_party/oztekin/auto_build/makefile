# Copyright 2013 B. Uygar Oztekin

SHELL=/bin/bash

# begin config
COMPILER ?= $(shell basename $(shell readlink -f `which g++ clang++ | head -n 1`))
VARIANT_FLAGS ?= -O0
INVARIANT_FLAGS ?= -std=c++11
INCLUDES ?= -I. $(shell find . -name include | sed 's/^/-I/' | tr '\n' ' ')
LIBRARIES ?= $(shell find . -name .libs | sed 's/^/-L/' | tr '\n' ' ')
SRC_ROOT ?= "."
OUT_ROOT ?= $(shell echo $(shell [ -d "$TMPDIR" ] && echo "$TMPDIR" || echo /tmp)/$(COMPILER) $(VARIANT_FLAGS) | sed 's/ /_/g')
# OBJS ?= $(shell find -name "*.cc" | grep -v third_party | sed 's!^./!!; s!^!$(OUT_ROOT)/!; s!\.cc$$!.o!')
BINS ?= $(shell find -name "*_test.cc" -o -name "_example.cc" | grep -v third_party | sed 's!^./!!; s!^!$(OUT_ROOT)/!; s!\.cc$$!!')
ANALYZE = $(OUT_ROOT)/analyze_source
# end config

CXX = $(COMPILER)
CXXFLAGS = $(VARIANT_FLAGS) $(INVARIANT_FLAGS)

.SUFFIXES:
.DELETE_ON_ERROR:
.SECONDEXPANSION:
.PHONY: all clean
# .SECONDARY $(OUT_ROOT)/%.o $(OUT_ROOT)/%.d $(OUT_ROOT)/%.dep $(OUT_ROOT)/%.l:

all: $(BINS) $(ANALYZE)

# Build the recursive dependency analyzer if needed.
# Dependency analyzer takes a .cc file and generates corresponding .dep and .l
# files. The .dep file of a binary contains the .o files it needs to link.
# The .l file contains the extra linker flags (if any) that needs to be passed.
# If the binary requires a system installed library to be linked against,
# analyzer adds this information to the .l file.
$(ANALYZE) : third_party/oztekin/auto_build/analyze_source.cc
	@echo [init] Bootstrapping the build system analyzer
	@mkdir -p $(OUT_ROOT)
	@$(CXX) -std=c++11 -O2 $< -o $@

# An object file depends on the .cc file and the dependency file generated by
# the compiler. First time you compile a .o file, dependency information won't
# be available, but subsequent times, it will be read and processed. If any of
# the dependencies changed, it will need to be recompiled.
$(OUT_ROOT)/%.o $(OUT_ROOT)/%.d : %.cc
	@echo [comp] $*
	@mkdir -p $(shell dirname $@)
	@$(CXX) $(CXXFLAGS) $(INCLUDES) -MMD -c $< -o $(OUT_ROOT)/$*.o

# Recursive dependency generation rule used to generate a .dep and .l file out
# of a binary target's .cc file.
$(OUT_ROOT)/%.dep $(OUT_ROOT)/%.l : $(ANALYZE) $(OUT_ROOT)/%.o
	@echo [depn] $*
	@$(ANALYZE) $(OUT_ROOT) $*.cc

# Linker rule.
% : %.dep %.l %.d %.o
	@echo [link] $@ | sed 's!$(OUT_ROOT)/!!'
	@$(CXX) $(CXXFLAGS) $(LIBRARIES) $(shell cat $*.dep | sed 's/.*://g') $(shell cat $*.l) -o $@

# Cleanup rule. Since it is possible that the output directory may be pointed to
# an arbitrary directory. Let's be careful about nuking the contents. If we
# notice any files we don't recognise, abort and let the user cleanup manually.
clean :
	@if (find $(OUT_ROOT) -type f ! -name "*.o" ! -name "*.d" ! -name "*.l" ! -name "*.dep" ! -executable | grep .) ; then echo "Unexpected files found! Refusing to clean." ; exit 1 ; fi
	rm -rf $(OUT_ROOT)

# This step is important in letting the build system know of changes that would
# require rebuilding a subset of targets after the first build.
ifneq ($(MAKECMDGOALS),clean)
-include $(BINS:=.dep)
-include $(shell find $(OUT_ROOT) -name "*.d" 2>/dev/null)
# -include $(OBJS:%.o=%.d)
endif
