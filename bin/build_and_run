#!/bin/bash -e
# Copyright 2013 B. Uygar Oztekin
#
# Quick and dirty script that can be used to compile & run various binaries.
# It can be used to compile some of the open sourced targets as an example.
#
# This is NOT the build system (flash) used in Room77. Until we can open source
# that (needs some cleanups), this can be used to compile and run targets.
#
# This script does not need explicit rules, make files or hints in most cases.
# Examines the sources and guesses the dependencies automatically:
#
# - Uses compiler's dependency generation to get an initial set of files.
# - For any .h in dependencies, if there is a corresponding .cc, assumes that
#   it is also a dependency.
# - Recursively examines all dependencies keeping track of what it had already
#   processed.
# - .cc files are checked for the "// @flag: PARAMS" pattern. If found, PARAMS
#   are passed to the compiler / linker. This can be used to specify external
#   dependencies of that particular library outside of the codebase.
# - At the end, produces a list of compiler parameters and .cc files to compile.
#
# Does not know if the targets are "current". Builds from scratch every time.
# More sophisticated components should use the Room77 flash build system in the
# future.
#

# If there are no parameters assume that this is a symlink.
# Try to compile the .cc file with the same name as the symlink.
if [ -z "$1" ] ; then
  COMMAND="`readlink -f $0` $0.cc"
  echo Running via symlink...
  echo $COMMAND
  echo
  $COMMAND
  exit 0
fi

# Figure out the root directory we should use. All compilations and includes
# are assumed to be relative to this directory.
SRC_ROOT=`readlink -f $(dirname $(readlink -f $0))/../`

CC=`which $CC g++ clang++ | head -n 1`  # Pick a compiler (override with CC).
CCLINK="$CCLINK -lpthread"              # Most of our code uses multi-threading.
CCFLAGS="$CCFLAGS -std=c++11 -I $SRC_ROOT \
-I $SRC_ROOT/third_party/google/gmock/latest/include \
-L $SRC_ROOT/third_party/google/gmock/latest/lib/.libs \
-I $SRC_ROOT/third_party/google/gtest/latest/include \
-L $SRC_ROOT/third_party/google/gtest/latest/lib/.libs"

function check_files() {
  for i in $* ; do
    if [ -e $i ] ; then
      echo "$i"
      # Try to see if there are special flags within the source file.
      # We extract anything after "// @flags:"
      FLAGS=`grep "//[ ]*@flags:.*" "$i" | sed 's/.*@flags://g'`
      if [ -n "$FLAGS" ] ; then
        CCLINK="$CCFLAGS $FLAGS"
      fi
    fi
  done
}

function extract_flags() {
  cd $SRC_ROOT
  for i in $* ; do
    grep "//[ ]*@flags:.*" "$i" | sed 's/.*@flags://g'
  done
}

function relpath() {
  readlink -f $* | sed "s#$SRC_ROOT/##g"
}

# This will keep track of targets already checked.
declare -A checked_targets

# Recursively guess dependencies of targets.
function guess_libs() {
  TARGETS=""
  for i in `relpath $*` ; do
    if [ "${checked_targets[$i]}" != "1" ] ; then
      TARGETS="$TARGETS $i"
      checked_targets[$i]=1
      echo $i
    fi
  done
  if [ -n "$TARGETS" ] ; then
    cd $SRC_ROOT
    CC_FILES=$(relpath $(check_files $($CC $CCFLAGS -MM $TARGETS | sed 's/.*://g;s/\\//g' | xargs readlink -f 2>/dev/null | sed 's/\.h/\.cc/g' | sort | uniq)))
    guess_libs $CC_FILES
  fi
}

echo "Dependencies:"
TARGETS=`guess_libs $*`
echo $TARGETS

echo
echo "Extra flags:"
CCLINK="$CCLINK `extract_flags $TARGETS`"
echo $CCLINK

NAME=`basename $1 | sed 's/\.cc//g'`
TMP=/tmp

cd $SRC_ROOT

echo
echo "Compile command:"
echo $CC $CCLINK $CCFLAGS $TARGETS -o $TMP/$NAME
$CC $CCLINK $CCFLAGS $TARGETS -o $TMP/$NAME && echo && echo Running $TMP/$NAME ... && \
LD_LIBRARY_PATH="$SRC_ROOT/third_party/google/gmock/latest/lib/.libs:$SRC_ROOT/third_party/google/gtest/latest/lib/.libs" $TMP/$NAME
